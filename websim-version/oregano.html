<html><head><base href="https://oregano.game/"></head>
<body>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  #score, #ballsLeft {
    position: absolute;
    left: 10px;
    font-size: 24px;
    color: #333;
  }
  #score { top: 10px; }
  #ballsLeft { top: 40px; }
  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    display: none;
  }
  #restartButton, #resetBallButton {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }
  #resetBallButton {
    position: absolute;
    top: 70px;
    left: 10px;
    background-color: #f44336;
  }
  #extraBallMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    color: #4CAF50;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    display: none;
  }
</style>

<canvas id="gameCanvas"></canvas>
<div id="score">Score: 0</div>
<div id="ballsLeft">Balls: 10</div>
<button id="resetBallButton">Reset Ball</button>
<div id="gameOver">
  <h2>Game Over</h2>
  <p>Your score: <span id="finalScore"></span></p>
  <button id="restartButton">Restart</button>
</div>
<div id="extraBallMessage">Extra Ball!</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const ballsLeftElement = document.getElementById('ballsLeft');
  const gameOverElement = document.getElementById('gameOver');
  const finalScoreElement = document.getElementById('finalScore');
  const restartButton = document.getElementById('restartButton');
  const resetBallButton = document.getElementById('resetBallButton');
  const extraBallMessage = document.getElementById('extraBallMessage');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let score = 0;
  let ballsLeft = 10;
  let gameActive = true;

  // Matter.js setup
  let engine = Matter.Engine.create();
  let world = engine.world;

  // Cannon
  const cannon = {
    x: canvas.width / 2,
    y: 50,
    angle: 0,
    width: 60,
    height: 100,
    baseWidth: 80,
    baseHeight: 40,
    color: '#444',
    barrelColor: '#666'
  };

  // Ball
  let ball = null;

  // Stems and leaves
  let stems = [];
  let leaves = [];

  // Moving target
  const target = {
    x: canvas.width / 2,
    y: canvas.height - 20,
    width: 200,
    height: 20,
    color: '#00FF00',
    direction: 1,
    speed: 5
  };

  function createWalls() {
    const wallOptions = { isStatic: true, restitution: 0.7 };
    return [
      Matter.Bodies.rectangle(0, canvas.height / 2, 10, canvas.height, wallOptions),
      Matter.Bodies.rectangle(canvas.width, canvas.height / 2, 10, canvas.height, wallOptions)
    ];
  }

  // Create stems with bezier curves
  function createStem(startX, startY, endX, endY) {
    const controlPoint1X = startX + (endX - startX) / 3;
    const controlPoint1Y = startY + Math.random() * 100 - 50;
    const controlPoint2X = startX + 2 * (endX - startX) / 3;
    const controlPoint2Y = endY + Math.random() * 100 - 50;

    const points = [];
    for (let t = 0; t <= 1; t += 0.05) {
      const x = Math.pow(1-t, 3) * startX +
                3 * Math.pow(1-t, 2) * t * controlPoint1X +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2X +
                Math.pow(t, 3) * endX;
      const y = Math.pow(1-t, 3) * startY +
                3 * Math.pow(1-t, 2) * t * controlPoint1Y +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2Y +
                Math.pow(t, 3) * endY;
      points.push(Matter.Vector.create(x, y));
    }

    const stemBody = Matter.Bodies.fromVertices(
      (startX + endX) / 2,
      (startY + endY) / 2,
      [points],
      { isStatic: true, restitution: 0.7 }
    );

    return {
      body: stemBody,
      start: { x: startX, y: startY },
      end: { x: endX, y: endY },
      control1: { x: controlPoint1X, y: controlPoint1Y },
      control2: { x: controlPoint2X, y: controlPoint2Y },
      points: points
    };
  }

  function createStemsAndLeaves() {
    stems = [];
    leaves = [];
    const numStems = 5;
    const sectionWidth = canvas.width / numStems;

    for (let i = 0; i < numStems; i++) {
      let startX, startY, endX, endY;
      let attempts = 0;
      const maxAttempts = 10;

      do {
        startX = i * sectionWidth + Math.random() * (sectionWidth - 100);
        startY = Math.random() * (canvas.height - 300) + 150;
        endX = startX + Math.random() * 100 + 50;
        endY = startY + (Math.random() - 0.5) * 200;
        attempts++;
      } while (checkStemOverlap(startX, startY, endX, endY) && attempts < maxAttempts);

      if (attempts < maxAttempts) {
        const stem = createStem(startX, startY, endX, endY);
        stems.push(stem);
        Matter.World.add(world, stem.body);

        for (let j = 0; j < 5; j++) {
          const t = j / 4;
          const x = Math.pow(1-t, 3) * stem.start.x +
                    3 * Math.pow(1-t, 2) * t * stem.control1.x +
                    3 * (1-t) * Math.pow(t, 2) * stem.control2.x +
                    Math.pow(t, 3) * stem.end.x;
          const y = Math.pow(1-t, 3) * stem.start.y +
                    3 * Math.pow(1-t, 2) * t * stem.control1.y +
                    3 * (1-t) * Math.pow(t, 2) * stem.control2.y +
                    Math.pow(t, 3) * stem.end.y;
          const leaf = {
            x: x,
            y: y,
            radius: 20,
            color: '#228B22',
            active: true,
            falling: false,
            velocity: { x: 0, y: 0 },
            stemLength: 10,
            stemAngle: Math.random() * Math.PI * 2
          };
          leaves.push(leaf);
        }
      }
    }
  }

  function checkStemOverlap(startX, startY, endX, endY) {
    for (let stem of stems) {
      if (lineIntersects(startX, startY, endX, endY, stem.start.x, stem.start.y, stem.end.x, stem.end.y)) {
        return true;
      }
    }
    return false;
  }

  function lineIntersects(x1, y1, x2, y2, x3, y3, x4, y4) {
    const det = (x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1);
    if (det === 0) return false;

    const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
    const gamma = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;

    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
  }

  // Initial game setup
  Matter.World.add(world, createWalls());
  createStemsAndLeaves();

  // Mouse control
  canvas.addEventListener('mousemove', (event) => {
    if (!gameActive) return;
    const dx = event.clientX - cannon.x;
    const dy = event.clientY - cannon.y;
    cannon.angle = Math.atan2(dy, dx);
  });

  canvas.addEventListener('click', () => {
    if (!gameActive) return;
    fireBall();
  });

  function fireBall() {
    if (ball === null && ballsLeft > 0) {
      const ballRadius = 15;
      ball = Matter.Bodies.circle(cannon.x, cannon.y + cannon.height / 2, ballRadius, {
        restitution: 0.7,
        friction: 0.001
      });
      Matter.Body.applyForce(ball, ball.position, {
        x: Math.cos(cannon.angle) * 0.03,
        y: Math.sin(cannon.angle) * 0.03
      });
      Matter.World.add(world, ball);
      ballsLeft--;
      updateBallsLeft();
    }
  }

  function updateScore(points) {
    score += points;
    scoreElement.textContent = `Score: ${score}`;
  }

  function updateBallsLeft() {
    ballsLeftElement.textContent = `Balls: ${ballsLeft}`;
  }

  function showExtraBallMessage() {
    extraBallMessage.style.display = 'block';
    setTimeout(() => {
      extraBallMessage.style.display = 'none';
    }, 2000);
  }

  function endGame() {
    gameActive = false;
    finalScoreElement.textContent = score;
    gameOverElement.style.display = 'block';
  }

  function restartGame() {
    // Reset game state
    score = 0;
    ballsLeft = 10;
    gameActive = true;
    updateScore(0);
    updateBallsLeft();
    gameOverElement.style.display = 'none';

    // Clear existing world
    Matter.World.clear(world);
    Matter.Engine.clear(engine);

    // Create new world and engine
    engine = Matter.Engine.create();
    world = engine.world;

    // Recreate game elements
    Matter.World.add(world, createWalls());
    createStemsAndLeaves();

    // Remove existing ball
    if (ball) {
      Matter.World.remove(world, ball);
      ball = null;
    }
  }

  function resetBall() {
    if (ball) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft--;
      updateBallsLeft();
      if (ballsLeft === 0) {
        endGame();
      }
    }
  }

  restartButton.addEventListener('click', restartGame);
  resetBallButton.addEventListener('click', resetBall);

  function drawLeaf(ctx, leaf) {
    ctx.save();
    ctx.translate(leaf.x, leaf.y);
    ctx.rotate(leaf.stemAngle);

    // Draw stem
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, leaf.stemLength);
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw slightly pointed, almost circular leaf
    ctx.beginPath();
    ctx.moveTo(0, leaf.stemLength);
    ctx.bezierCurveTo(
      leaf.radius, leaf.stemLength,
      leaf.radius * 1.2, leaf.stemLength + leaf.radius * 1.5,
      0, leaf.stemLength + leaf.radius * 2.2
    );
    ctx.bezierCurveTo(
      -leaf.radius * 1.2, leaf.stemLength + leaf.radius * 1.5,
      -leaf.radius, leaf.stemLength,
      0, leaf.stemLength
    );
    ctx.fillStyle = leaf.color;
    ctx.fill();

    ctx.restore();
  }

  function drawCannon(ctx, cannon) {
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    
    // Draw base
    ctx.fillStyle = cannon.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, cannon.baseWidth / 2, cannon.baseHeight / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Draw barrel
    ctx.rotate(cannon.angle);
    ctx.fillStyle = cannon.barrelColor;
    ctx.fillRect(-cannon.width / 2, 0, cannon.width, cannon.height);

    // Draw barrel end
    ctx.beginPath();
    ctx.arc(0, cannon.height, cannon.width / 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update cannon
    drawCannon(ctx, cannon);

    // Update ball
    if (ball !== null) {
      ctx.beginPath();
      ctx.arc(ball.position.x, ball.position.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#FF0000';
      ctx.fill();

      if (ball.position.y > canvas.height) {
        Matter.World.remove(world, ball);
        ball = null;
        if (ballsLeft === 0) {
          endGame();
        }
      }
    }

    // Update stems
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 5;
    stems.forEach(stem => {
      ctx.beginPath();
      ctx.moveTo(stem.start.x, stem.start.y);
      ctx.bezierCurveTo(stem.control1.x, stem.control1.y, stem.control2.x, stem.control2.y, stem.end.x, stem.end.y);
      ctx.stroke();
    });

    // Update leaves
    leaves.forEach(leaf => {
      if (leaf.active || leaf.falling) {
        drawLeaf(ctx, leaf);

        if (leaf.falling) {
          leaf.velocity.y += 0.1; // Gravity
          leaf.x += leaf.velocity.x;
          leaf.y += leaf.velocity.y;
          leaf.stemAngle += 0.1; // Rotate the stem as it falls

          if (leaf.y > canvas.height) {
            leaf.falling = false;
          }
        } else if (leaf.active && ball !== null) {
          const dx = ball.position.x - leaf.x;
          const dy = ball.position.y - leaf.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < ball.circleRadius + leaf.radius) {
            leaf.active = false;
            leaf.falling = true;
            leaf.velocity = {
              x: (Math.random() - 0.5) * 2,
              y: -2 - Math.random() * 2
            };
            updateScore(10);
          }
        }
      }
    });

    // Update target
    target.x += target.direction * target.speed;
    if (target.x - target.width / 2 < 0 || target.x + target.width / 2 > canvas.width) {
      target.direction *= -1;
    }
    ctx.fillStyle = target.color;
    ctx.fillRect(target.x - target.width / 2, target.y - target.height / 2, target.width, target.height);

    // Check if ball hits target
    if (ball !== null && 
        ball.position.x > target.x - target.width / 2 &&
        ball.position.x < target.x + target.width / 2 &&
        ball.position.y > target.y - target.height / 2 &&
        ball.position.y < target.y + target.height / 2) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft++;
      updateBallsLeft();
      showExtraBallMessage();
    }

    Matter.Engine.update(engine);
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body></html>