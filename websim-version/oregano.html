<html><head><base href="https://oregano.game/"></head>
<body>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  #score, #ballsLeft {
    position: absolute;
    left: 10px;
    font-size: 24px;
    color: #333;
  }
  #score { top: 10px; }
  #ballsLeft { top: 40px; }
  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    display: none;
  }
  #restartButton, #resetBallButton {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }
  #resetBallButton {
    position: absolute;
    top: 70px;
    left: 10px;
    background-color: #f44336;
  }
</style>

<canvas id="gameCanvas"></canvas>
<div id="score">Score: 0</div>
<div id="ballsLeft">Balls: 5</div>
<button id="resetBallButton">Reset Ball</button>
<div id="gameOver">
  <h2>Game Over</h2>
  <p>Your score: <span id="finalScore"></span></p>
  <button id="restartButton">Restart</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const ballsLeftElement = document.getElementById('ballsLeft');
  const gameOverElement = document.getElementById('gameOver');
  const finalScoreElement = document.getElementById('finalScore');
  const restartButton = document.getElementById('restartButton');
  const resetBallButton = document.getElementById('resetBallButton');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let score = 0;
  let ballsLeft = 5;
  let gameActive = true;

  // Matter.js setup
  let engine = Matter.Engine.create();
  let world = engine.world;

  // Cannon
  const cannon = {
    x: canvas.width / 2,
    y: 50,
    angle: 0,
    width: 40,
    height: 80,
    color: '#444'
  };

  // Ball
  let ball = null;

  // Stems and leaves
  let stems = [];
  let leaves = [];

  // Moving target
  const target = {
    x: canvas.width / 2,
    y: canvas.height - 20,
    width: 100,
    height: 10,
    color: '#00FF00',
    direction: 1,
    speed: 5
  };

  function createWalls() {
    const wallOptions = { isStatic: true, restitution: 0.7 };
    return [
      Matter.Bodies.rectangle(0, canvas.height / 2, 10, canvas.height, wallOptions),
      Matter.Bodies.rectangle(canvas.width, canvas.height / 2, 10, canvas.height, wallOptions)
    ];
  }

  // Create stems with bezier curves
  function createStem(startX, startY, endX, endY) {
    const controlPoint1X = startX + (endX - startX) / 3;
    const controlPoint1Y = startY + Math.random() * 100 - 50;
    const controlPoint2X = startX + 2 * (endX - startX) / 3;
    const controlPoint2Y = endY + Math.random() * 100 - 50;

    const points = [];
    for (let t = 0; t <= 1; t += 0.05) {
      const x = Math.pow(1-t, 3) * startX +
                3 * Math.pow(1-t, 2) * t * controlPoint1X +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2X +
                Math.pow(t, 3) * endX;
      const y = Math.pow(1-t, 3) * startY +
                3 * Math.pow(1-t, 2) * t * controlPoint1Y +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2Y +
                Math.pow(t, 3) * endY;
      points.push(Matter.Vector.create(x, y));
    }

    const stemBody = Matter.Bodies.fromVertices(
      (startX + endX) / 2,
      (startY + endY) / 2,
      [points],
      { isStatic: true, restitution: 0.7 }
    );

    return {
      body: stemBody,
      start: { x: startX, y: startY },
      end: { x: endX, y: endY },
      control1: { x: controlPoint1X, y: controlPoint1Y },
      control2: { x: controlPoint2X, y: controlPoint2Y },
      points: points
    };
  }

  function createStemsAndLeaves() {
    stems = [];
    leaves = [];
    for (let i = 0; i < 5; i++) {
      const stem = createStem(
        Math.random() * (canvas.width - 400) + 200,
        Math.random() * (canvas.height - 300) + 150,
        Math.random() * (canvas.width - 400) + 200,
        Math.random() * (canvas.height - 300) + 150
      );
      stems.push(stem);
      Matter.World.add(world, stem.body);

      for (let j = 0; j < 5; j++) {
        const t = j / 4;
        const x = Math.pow(1-t, 3) * stem.start.x +
                  3 * Math.pow(1-t, 2) * t * stem.control1.x +
                  3 * (1-t) * Math.pow(t, 2) * stem.control2.x +
                  Math.pow(t, 3) * stem.end.x;
        const y = Math.pow(1-t, 3) * stem.start.y +
                  3 * Math.pow(1-t, 2) * t * stem.control1.y +
                  3 * (1-t) * Math.pow(t, 2) * stem.control2.y +
                  Math.pow(t, 3) * stem.end.y;
        const leaf = {
          x: x,
          y: y - 20,
          radius: 15,
          color: '#228B22',
          active: true,
          falling: false,
          velocity: { x: 0, y: 0 },
          stemLength: 20,
          stemAngle: Math.random() * Math.PI
        };
        leaves.push(leaf);
      }
    }
  }

  // Initial game setup
  Matter.World.add(world, createWalls());
  createStemsAndLeaves();

  // Mouse control
  canvas.addEventListener('mousemove', (event) => {
    if (!gameActive) return;
    const dx = event.clientX - cannon.x;
    const dy = event.clientY - cannon.y;
    cannon.angle = Math.atan2(dy, dx);
  });

  canvas.addEventListener('click', () => {
    if (!gameActive) return;
    fireBall();
  });

  function fireBall() {
    if (ball === null && ballsLeft > 0) {
      const ballRadius = 15;
      ball = Matter.Bodies.circle(cannon.x, cannon.y, ballRadius, {
        restitution: 0.7,
        friction: 0.001
      });
      Matter.Body.applyForce(ball, ball.position, {
        x: Math.cos(cannon.angle) * 0.05,
        y: Math.sin(cannon.angle) * 0.05
      });
      Matter.World.add(world, ball);
      ballsLeft--;
      updateBallsLeft();
    }
  }

  function updateScore(points) {
    score += points;
    scoreElement.textContent = `Score: ${score}`;
  }

  function updateBallsLeft() {
    ballsLeftElement.textContent = `Balls: ${ballsLeft}`;
  }

  function endGame() {
    gameActive = false;
    finalScoreElement.textContent = score;
    gameOverElement.style.display = 'block';
  }

  function restartGame() {
    // Reset game state
    score = 0;
    ballsLeft = 5;
    gameActive = true;
    updateScore(0);
    updateBallsLeft();
    gameOverElement.style.display = 'none';

    // Clear existing world
    Matter.World.clear(world);
    Matter.Engine.clear(engine);

    // Create new world and engine
    engine = Matter.Engine.create();
    world = engine.world;

    // Recreate game elements
    Matter.World.add(world, createWalls());
    createStemsAndLeaves();

    // Remove existing ball
    if (ball) {
      Matter.World.remove(world, ball);
      ball = null;
    }
  }

  function resetBall() {
    if (ball) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft--;
      updateBallsLeft();
      if (ballsLeft === 0) {
        endGame();
      }
    }
  }

  restartButton.addEventListener('click', restartGame);
  resetBallButton.addEventListener('click', resetBall);

  function drawPointedLeaf(ctx, x, y, radius, stemLength, stemAngle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(stemAngle);

    // Draw stem
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, stemLength);
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw pointed leaf
    ctx.beginPath();
    ctx.moveTo(0, stemLength);
    ctx.quadraticCurveTo(radius, stemLength + radius / 2, 0, stemLength + radius * 2);
    ctx.quadraticCurveTo(-radius, stemLength + radius / 2, 0, stemLength);
    ctx.fillStyle = color;
    ctx.fill();

    ctx.restore();
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update cannon
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    ctx.rotate(cannon.angle);
    ctx.fillStyle = cannon.color;
    ctx.fillRect(-cannon.width / 2, -cannon.height / 2, cannon.width, cannon.height);
    ctx.restore();

    // Update ball
    if (ball !== null) {
      ctx.beginPath();
      ctx.arc(ball.position.x, ball.position.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#FF0000';
      ctx.fill();

      if (ball.position.y > canvas.height) {
        Matter.World.remove(world, ball);
        ball = null;
        if (ballsLeft === 0) {
          endGame();
        }
      }
    }

    // Update stems
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 5;
    stems.forEach(stem => {
      ctx.beginPath();
      ctx.moveTo(stem.start.x, stem.start.y);
      ctx.bezierCurveTo(stem.control1.x, stem.control1.y, stem.control2.x, stem.control2.y, stem.end.x, stem.end.y);
      ctx.stroke();
    });

    // Update leaves
    leaves.forEach(leaf => {
      if (leaf.active || leaf.falling) {
        drawPointedLeaf(ctx, leaf.x, leaf.y, leaf.radius, leaf.stemLength, leaf.stemAngle, leaf.color);

        if (leaf.falling) {
          leaf.velocity.y += 0.1; // Gravity
          leaf.x += leaf.velocity.x;
          leaf.y += leaf.velocity.y;
          leaf.stemAngle += 0.1; // Rotate the stem as it falls

          if (leaf.y > canvas.height) {
            leaf.falling = false;
          }
        } else if (leaf.active && ball !== null) {
          const dx = ball.position.x - leaf.x;
          const dy = ball.position.y - leaf.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < ball.circleRadius + leaf.radius) {
            leaf.active = false;
            leaf.falling = true;
            leaf.velocity = {
              x: (Math.random() - 0.5) * 2,
              y: -2 - Math.random() * 2
            };
            updateScore(10);
          }
        }
      }
    });

    // Update target
    target.x += target.direction * target.speed;
    if (target.x < 0 || target.x > canvas.width) {
      target.direction *= -1;
    }
    ctx.fillStyle = target.color;
    ctx.fillRect(target.x - target.width / 2, target.y - target.height / 2, target.width, target.height);

    // Check if ball hits target
    if (ball !== null && 
        ball.position.x > target.x - target.width / 2 &&
        ball.position.x < target.x + target.width / 2 &&
        ball.position.y > target.y - target.height / 2 &&
        ball.position.y < target.y + target.height / 2) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft++;
      updateBallsLeft();
    }

    Matter.Engine.update(engine);
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body></html>