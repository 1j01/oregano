<html><head><base href="https://oregano.game/"></head>
<body>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  #score {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 24px;
    color: #333;
  }
  #ballsLeft {
    position: absolute;
    top: 40px;
    left: 10px;
    font-size: 18px;
    color: #333;
  }
</style>

<canvas id="gameCanvas"></canvas>
<div id="score">Score: 0</div>
<div id="ballsLeft">Balls: 5</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const ballsLeftElement = document.getElementById('ballsLeft');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let score = 0;
  let ballsLeft = 5;

  // Matter.js setup
  const engine = Matter.Engine.create();
  const world = engine.world;

  // Cannon
  const cannon = {
    x: canvas.width / 2,
    y: 50,
    angle: 0,
    width: 40,
    height: 80,
    color: '#444'
  };

  // Ball
  let ball = null;

  // Stems and leaves
  const stems = [];
  const leaves = [];

  // Moving target
  const target = {
    x: canvas.width / 2,
    y: canvas.height - 20,
    width: 100,
    height: 10,
    color: '#00FF00',
    direction: 1,
    speed: 5
  };

  // Create stems and leaves
  for (let i = 0; i < 5; i++) {
    const stem = Matter.Bodies.rectangle(
      Math.random() * (canvas.width - 200) + 100,
      Math.random() * (canvas.height - 300) + 150,
      200,
      10,
      { isStatic: true, angle: Math.random() * Math.PI / 4 - Math.PI / 8 }
    );
    stems.push(stem);
    Matter.World.add(world, stem);

    for (let j = 0; j < 5; j++) {
      const leaf = {
        x: stem.position.x + (j - 2) * 40,
        y: stem.position.y - 20,
        width: 20,
        height: 30,
        color: '#228B22',
        active: true
      };
      leaves.push(leaf);
    }
  }

  // Mouse control
  canvas.addEventListener('mousemove', (event) => {
    const dx = event.clientX - cannon.x;
    const dy = event.clientY - cannon.y;
    cannon.angle = Math.atan2(dy, dx);
  });

  canvas.addEventListener('click', () => {
    if (ball === null && ballsLeft > 0) {
      const ballRadius = 15;
      ball = Matter.Bodies.circle(cannon.x, cannon.y, ballRadius, {
        restitution: 0.7,
        friction: 0.001
      });
      Matter.Body.applyForce(ball, ball.position, {
        x: Math.cos(cannon.angle) * 0.05,
        y: Math.sin(cannon.angle) * 0.05
      });
      Matter.World.add(world, ball);
      ballsLeft--;
      updateBallsLeft();
    }
  });

  function updateScore(points) {
    score += points;
    scoreElement.textContent = `Score: ${score}`;
  }

  function updateBallsLeft() {
    ballsLeftElement.textContent = `Balls: ${ballsLeft}`;
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update cannon
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    ctx.rotate(cannon.angle);
    ctx.fillStyle = cannon.color;
    ctx.fillRect(-cannon.width / 2, -cannon.height / 2, cannon.width, cannon.height);
    ctx.restore();

    // Update ball
    if (ball !== null) {
      ctx.beginPath();
      ctx.arc(ball.position.x, ball.position.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#FF0000';
      ctx.fill();

      if (ball.position.y > canvas.height) {
        Matter.World.remove(world, ball);
        ball = null;
      }
    }

    // Update stems
    ctx.fillStyle = '#8B4513';
    stems.forEach(stem => {
      ctx.save();
      ctx.translate(stem.position.x, stem.position.y);
      ctx.rotate(stem.angle);
      ctx.fillRect(-100, -5, 200, 10);
      ctx.restore();
    });

    // Update leaves
    leaves.forEach(leaf => {
      if (leaf.active) {
        ctx.fillStyle = leaf.color;
        ctx.fillRect(leaf.x - leaf.width / 2, leaf.y - leaf.height / 2, leaf.width, leaf.height);

        if (ball !== null) {
          const dx = ball.position.x - leaf.x;
          const dy = ball.position.y - leaf.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 20) {
            leaf.active = false;
            updateScore(10);
          }
        }
      }
    });

    // Update target
    target.x += target.direction * target.speed;
    if (target.x < 0 || target.x > canvas.width) {
      target.direction *= -1;
    }
    ctx.fillStyle = target.color;
    ctx.fillRect(target.x - target.width / 2, target.y - target.height / 2, target.width, target.height);

    // Check if ball hits target
    if (ball !== null && 
        ball.position.x > target.x - target.width / 2 &&
        ball.position.x < target.x + target.width / 2 &&
        ball.position.y > target.y - target.height / 2 &&
        ball.position.y < target.y + target.height / 2) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft++;
      updateBallsLeft();
    }

    Matter.Engine.update(engine);
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body></html>