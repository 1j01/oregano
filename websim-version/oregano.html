<html><head><base href="https://oregano.game/"></head>
<body>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  #score, #ballsLeft {
    position: absolute;
    left: 10px;
    font-size: 24px;
    color: #333;
  }
  #score { top: 10px; }
  #ballsLeft { top: 40px; }
  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    display: none;
  }
  #restartButton {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }
</style>

<canvas id="gameCanvas"></canvas>
<div id="score">Score: 0</div>
<div id="ballsLeft">Balls: 5</div>
<div id="gameOver">
  <h2>Game Over</h2>
  <p>Your score: <span id="finalScore"></span></p>
  <button id="restartButton">Restart</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const ballsLeftElement = document.getElementById('ballsLeft');
  const gameOverElement = document.getElementById('gameOver');
  const finalScoreElement = document.getElementById('finalScore');
  const restartButton = document.getElementById('restartButton');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let score = 0;
  let ballsLeft = 5;
  let gameActive = true;

  // Matter.js setup
  const engine = Matter.Engine.create();
  const world = engine.world;

  // Cannon
  const cannon = {
    x: canvas.width / 2,
    y: 50,
    angle: 0,
    width: 40,
    height: 80,
    color: '#444'
  };

  // Ball
  let ball = null;

  // Stems and leaves
  const stems = [];
  const leaves = [];

  // Moving target
  const target = {
    x: canvas.width / 2,
    y: canvas.height - 20,
    width: 100,
    height: 10,
    color: '#00FF00',
    direction: 1,
    speed: 5
  };

  // Create walls (only on sides)
  const wallOptions = { isStatic: true, restitution: 0.7 };
  Matter.World.add(world, [
    Matter.Bodies.rectangle(0, canvas.height / 2, 10, canvas.height, wallOptions),
    Matter.Bodies.rectangle(canvas.width, canvas.height / 2, 10, canvas.height, wallOptions)
  ]);

  // Create stems with bezier curves
  function createStem(startX, startY, endX, endY) {
    const controlPoint1X = startX + (endX - startX) / 3;
    const controlPoint1Y = startY + Math.random() * 100 - 50;
    const controlPoint2X = startX + 2 * (endX - startX) / 3;
    const controlPoint2Y = endY + Math.random() * 100 - 50;

    const points = [];
    for (let t = 0; t <= 1; t += 0.1) {
      const x = Math.pow(1-t, 3) * startX +
                3 * Math.pow(1-t, 2) * t * controlPoint1X +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2X +
                Math.pow(t, 3) * endX;
      const y = Math.pow(1-t, 3) * startY +
                3 * Math.pow(1-t, 2) * t * controlPoint1Y +
                3 * (1-t) * Math.pow(t, 2) * controlPoint2Y +
                Math.pow(t, 3) * endY;
      points.push({ x, y });
    }

    const stemBody = Matter.Bodies.fromVertices(
      (startX + endX) / 2,
      (startY + endY) / 2,
      [points],
      { isStatic: true, restitution: 0.7 }
    );

    return {
      body: stemBody,
      start: { x: startX, y: startY },
      end: { x: endX, y: endY },
      control1: { x: controlPoint1X, y: controlPoint1Y },
      control2: { x: controlPoint2X, y: controlPoint2Y }
    };
  }

  // Create stems and leaves
  for (let i = 0; i < 5; i++) {
    const stem = createStem(
      Math.random() * (canvas.width - 400) + 200,
      Math.random() * (canvas.height - 300) + 150,
      Math.random() * (canvas.width - 400) + 200,
      Math.random() * (canvas.height - 300) + 150
    );
    stems.push(stem);
    Matter.World.add(world, stem.body);

    for (let j = 0; j < 5; j++) {
      const t = j / 4;
      const x = Math.pow(1-t, 3) * stem.start.x +
                3 * Math.pow(1-t, 2) * t * stem.control1.x +
                3 * (1-t) * Math.pow(t, 2) * stem.control2.x +
                Math.pow(t, 3) * stem.end.x;
      const y = Math.pow(1-t, 3) * stem.start.y +
                3 * Math.pow(1-t, 2) * t * stem.control1.y +
                3 * (1-t) * Math.pow(t, 2) * stem.control2.y +
                Math.pow(t, 3) * stem.end.y;
      const leaf = {
        x: x,
        y: y - 20,
        radius: 15,
        color: '#228B22',
        active: true
      };
      leaves.push(leaf);
    }
  }

  // Mouse control
  canvas.addEventListener('mousemove', (event) => {
    if (!gameActive) return;
    const dx = event.clientX - cannon.x;
    const dy = event.clientY - cannon.y;
    cannon.angle = Math.atan2(dy, dx);
  });

  canvas.addEventListener('click', () => {
    if (!gameActive) return;
    if (ball === null && ballsLeft > 0) {
      const ballRadius = 15;
      ball = Matter.Bodies.circle(cannon.x, cannon.y, ballRadius, {
        restitution: 0.7,
        friction: 0.001
      });
      Matter.Body.applyForce(ball, ball.position, {
        x: Math.cos(cannon.angle) * 0.05,
        y: Math.sin(cannon.angle) * 0.05
      });
      Matter.World.add(world, ball);
      ballsLeft--;
      updateBallsLeft();
    }
  });

  function updateScore(points) {
    score += points;
    scoreElement.textContent = `Score: ${score}`;
  }

  function updateBallsLeft() {
    ballsLeftElement.textContent = `Balls: ${ballsLeft}`;
  }

  function endGame() {
    gameActive = false;
    finalScoreElement.textContent = score;
    gameOverElement.style.display = 'block';
  }

  function restartGame() {
    score = 0;
    ballsLeft = 5;
    gameActive = true;
    updateScore(0);
    updateBallsLeft();
    gameOverElement.style.display = 'none';
    if (ball) {
      Matter.World.remove(world, ball);
      ball = null;
    }
    leaves.forEach(leaf => leaf.active = true);
  }

  restartButton.addEventListener('click', restartGame);

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update cannon
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    ctx.rotate(cannon.angle);
    ctx.fillStyle = cannon.color;
    ctx.fillRect(-cannon.width / 2, -cannon.height / 2, cannon.width, cannon.height);
    ctx.restore();

    // Update ball
    if (ball !== null) {
      ctx.beginPath();
      ctx.arc(ball.position.x, ball.position.y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#FF0000';
      ctx.fill();

      if (ball.position.y > canvas.height) {
        Matter.World.remove(world, ball);
        ball = null;
        if (ballsLeft === 0) {
          endGame();
        }
      }
    }

    // Update stems
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 5;
    stems.forEach(stem => {
      ctx.beginPath();
      ctx.moveTo(stem.start.x, stem.start.y);
      ctx.bezierCurveTo(stem.control1.x, stem.control1.y, stem.control2.x, stem.control2.y, stem.end.x, stem.end.y);
      ctx.stroke();
    });

    // Update leaves
    leaves.forEach(leaf => {
      if (leaf.active) {
        ctx.beginPath();
        ctx.arc(leaf.x, leaf.y, leaf.radius, 0, Math.PI * 2);
        ctx.fillStyle = leaf.color;
        ctx.fill();

        if (ball !== null) {
          const dx = ball.position.x - leaf.x;
          const dy = ball.position.y - leaf.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < ball.circleRadius + leaf.radius) {
            leaf.active = false;
            updateScore(10);
          }
        }
      }
    });

    // Update target
    target.x += target.direction * target.speed;
    if (target.x < 0 || target.x > canvas.width) {
      target.direction *= -1;
    }
    ctx.fillStyle = target.color;
    ctx.fillRect(target.x - target.width / 2, target.y - target.height / 2, target.width, target.height);

    // Check if ball hits target
    if (ball !== null && 
        ball.position.x > target.x - target.width / 2 &&
        ball.position.x < target.x + target.width / 2 &&
        ball.position.y > target.y - target.height / 2 &&
        ball.position.y < target.y + target.height / 2) {
      Matter.World.remove(world, ball);
      ball = null;
      ballsLeft++;
      updateBallsLeft();
    }

    Matter.Engine.update(engine);
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body></html>